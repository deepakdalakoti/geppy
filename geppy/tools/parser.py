# coding=utf-8
"""
.. moduleauthor:: Shuhua Gao

This module :mod:`parser` provides functionality for compiling an individual (a chromosome) in GEP into an executable
lambda function in Python for subsequent fitness evaluation.

.. todo::
    Parse an individual into codes of other languages, such as C++/Java, for deployment in an industrial environment.
"""

import sys
import operator
import numpy as np

def trace(x1):
    
    if(np.isscalar(x1)):
        return x1
    return np.trace(x1)

def _compile_gene(g, pset):
    """
    Compile one gene *g* with the primitive set *pset*.
    :return: a function or an evaluated result
    """
    code = str(g)
    if len(pset.input_names) > 0:   # form a Lambda function
        args = ', '.join(pset.input_names)
        code =  'lambda {}: {}'.format(args, code)
    # evaluate the code
    try:
        return eval(code, pset.globals, {})
    except MemoryError:
        _, _, traceback = sys.exc_info()
        raise MemoryError("The expression tree generated by GEP is too deep. Python cannot evaluate a tree higher "
                          "than 90. You should try to adopt a smaller head length for the genes, for example, by using"
                          "more genes in a chromosome.").with_traceback(traceback)

def _compile_plasmid_gene(g, pset,pset_plasmid):
    """
    Compile one gene *g* with the primitive set *pset*.
    :return: a function or an evaluated result
    """
    code = str(g)
    if len(pset.input_names) > 0:   # form a Lambda function
        inps = pset.input_names + pset_plasmid.input_names
         # Disaster waiting to happen, inps has to be in the same order as used in evaluation func
#        inps = pset.input_names
#        inps = list(set(inps))
        args = ', '.join(inps)
        code =  'lambda {}: {}'.format(args, code)
    # evaluate the code
    try:
        globs = pset.globals
        globs.update(pset_plasmid.globals)
# Here add mult function for linker because input set might not always have one
        globs.update({'mul':operator.mul})
        globs.update({'trace':trace})


        return eval(code, globs, {})
    except MemoryError:
        _, _, traceback = sys.exc_info()
        raise MemoryError("The expression tree generated by GEP is too deep. Python cannot evaluate a tree higher "
                          "than 90. You should try to adopt a smaller head length for the genes, for example, by using"
                          "more genes in a chromosome.").with_traceback(traceback)
def compile_plasmids(individual, pset,pset_plasmid):
    """
    Compile the individual into a Python lambda expression.

    :param individual: :class:`Chromosome`, a chromosome
    :param pset: :class:`PrimitiveSet`, a primitive set
    :return: a function if the primitive set *pset* has any inputs (arguments), which can later be called with
        specific parameter values; otherwise, a numerical result obtained from evaluation.
    """
    fs = [_compile_plasmid_gene(gene, pset, pset_plasmid) for gene in individual]
    linker = individual.linker
    if linker is None:
        if len(fs) == 1:
            return fs[0]
        else:
            return lambda *x: tuple((f(*x) for f in fs))
    return lambda *x: linker(*(f(*x) for f in fs))



def compile_(individual, pset):
    """
    Compile the individual into a Python lambda expression.

    :param individual: :class:`Chromosome`, a chromosome
    :param pset: :class:`PrimitiveSet`, a primitive set
    :return: a function if the primitive set *pset* has any inputs (arguments), which can later be called with
        specific parameter values; otherwise, a numerical result obtained from evaluation.
    """
    fs = [_compile_gene(gene, pset) for gene in individual]
    linker = individual.linker
    if linker is None:
        if len(fs) == 1:
            return fs[0]
        else:
            return lambda *x: tuple((f(*x) for f in fs))
    return lambda *x: linker(*(f(*x) for f in fs))


__all__ = ['compile_','_compile_plasmid_gene','compile_plasmids']
